From 0f474287178cfdf0a06e16545d131340d07d8b76 Mon Sep 17 00:00:00 2001
From: Srinivasan Muralidharan <srinivasan.muralidharan99@gmail.com>
Date: Sun, 8 Apr 2018 17:46:14 -0400
Subject: [PATCH] [FAB-9401] sanitize resource names and add doc

Cleans up resource names to be consistent with respect
to case, changes names to be more descriptive where
necessary and adds doc to resource name to indicate where
they are used.

Change-Id: I6d30548c7b5da0f88800a593694e70d1c093057f
Signed-off-by: Srinivasan Muralidharan <srinivasan.muralidharan99@gmail.com>
---
 core/aclmgmt/aclmgmt_test.go             | 10 ++--
 core/aclmgmt/defaultaclprovider.go       | 50 +++++++++--------
 core/aclmgmt/resources/resources.go      | 61 +++++++++++----------
 core/chaincode/chaincode_support_test.go | 90 +++++++++++++++----------------
 core/chaincode/handler.go                |  2 +-
 core/endorser/support.go                 |  2 +-
 core/peer/deliverevents.go               |  4 +-
 core/scc/cscc/configure.go               |  6 +--
 core/scc/cscc/configure_test.go          |  6 +--
 core/scc/lscc/lscc.go                    | 16 +++---
 core/scc/lscc/lscc_test.go               | 20 +++----
 core/scc/qscc/query.go                   |  2 +-
 core/scc/qscc/query_test.go              | 32 +++++------
 sampleconfig/configtx.yaml               | 92 ++++++++++++++++++++++----------
 14 files changed, 213 insertions(+), 180 deletions(-)

diff --git a/core/aclmgmt/aclmgmt_test.go b/core/aclmgmt/aclmgmt_test.go
index 48cfa45..06bb618 100644
--- a/core/aclmgmt/aclmgmt_test.go
+++ b/core/aclmgmt/aclmgmt_test.go
@@ -50,7 +50,7 @@ func TestRegisterNilProvider(t *testing.T) {
 func TestBadID(t *testing.T) {
 	reinit()
 	RegisterACLProvider(nil)
-	err := GetACLProvider().CheckACL(resources.PROPOSE, "somechain", "badidtype")
+	err := GetACLProvider().CheckACL(resources.Peer_Propose, "somechain", "badidtype")
 	assert.Error(t, err, "Expected error")
 }
 
@@ -65,8 +65,8 @@ func TestWithProvider(t *testing.T) {
 	reinit()
 	aclprov := registerACLProvider()
 	prop := &pb.SignedProposal{}
-	aclprov.On("CheckACL", resources.PROPOSE, "somechain", prop).Return(nil)
-	err := GetACLProvider().CheckACL(resources.PROPOSE, "somechain", prop)
+	aclprov.On("CheckACL", resources.Peer_Propose, "somechain", prop).Return(nil)
+	err := GetACLProvider().CheckACL(resources.Peer_Propose, "somechain", prop)
 	assert.NoError(t, err)
 }
 
@@ -74,7 +74,7 @@ func TestBadACL(t *testing.T) {
 	reinit()
 	aclprov := registerACLProvider()
 	prop := &pb.SignedProposal{}
-	aclprov.On("CheckACL", resources.PROPOSE, "somechain", prop).Return(errors.New("badacl"))
-	err := GetACLProvider().CheckACL(resources.PROPOSE, "somechain", prop)
+	aclprov.On("CheckACL", resources.Peer_Propose, "somechain", prop).Return(errors.New("badacl"))
+	err := GetACLProvider().CheckACL(resources.Peer_Propose, "somechain", prop)
 	assert.Error(t, err, "Expected error")
 }
diff --git a/core/aclmgmt/defaultaclprovider.go b/core/aclmgmt/defaultaclprovider.go
index 023658d..332956b 100644
--- a/core/aclmgmt/defaultaclprovider.go
+++ b/core/aclmgmt/defaultaclprovider.go
@@ -54,47 +54,45 @@ func (d *defaultACLProvider) initialize() {
 
 	//-------------- LSCC --------------
 	//p resources (implemented by the chaincode currently)
-	d.pResourcePolicyMap[resources.LSCC_INSTALL] = ""
-	d.pResourcePolicyMap[resources.LSCC_GETCHAINCODES] = ""
-	d.pResourcePolicyMap[resources.LSCC_GETINSTALLEDCHAINCODES] = ""
+	d.pResourcePolicyMap[resources.Lscc_Install] = ""
+	d.pResourcePolicyMap[resources.Lscc_GetInstantiatedChaincodes] = ""
+	d.pResourcePolicyMap[resources.Lscc_GetInstalledChaincodes] = ""
 
 	//c resources
-	d.cResourcePolicyMap[resources.LSCC_DEPLOY] = ""  //ACL check covered by PROPOSAL
-	d.cResourcePolicyMap[resources.LSCC_UPGRADE] = "" //ACL check covered by PROPOSAL
-	d.cResourcePolicyMap[resources.LSCC_GETCCINFO] = CHANNELREADERS
-	d.cResourcePolicyMap[resources.LSCC_GETDEPSPEC] = CHANNELREADERS
-	d.cResourcePolicyMap[resources.LSCC_GETCCDATA] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Lscc_Deploy] = ""  //ACL check covered by PROPOSAL
+	d.cResourcePolicyMap[resources.Lscc_Upgrade] = "" //ACL check covered by PROPOSAL
+	d.cResourcePolicyMap[resources.Lscc_ChaincodeExists] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Lscc_GetDeploymentSpec] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Lscc_GetChaincodeData] = CHANNELREADERS
 
 	//-------------- QSCC --------------
 	//p resources (none)
 
 	//c resources
-	d.cResourcePolicyMap[resources.QSCC_GetChainInfo] = CHANNELREADERS
-	d.cResourcePolicyMap[resources.QSCC_GetBlockByNumber] = CHANNELREADERS
-	d.cResourcePolicyMap[resources.QSCC_GetBlockByHash] = CHANNELREADERS
-	d.cResourcePolicyMap[resources.QSCC_GetTransactionByID] = CHANNELREADERS
-	d.cResourcePolicyMap[resources.QSCC_GetBlockByTxID] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Qscc_GetChainInfo] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Qscc_GetBlockByNumber] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Qscc_GetBlockByHash] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Qscc_GetTransactionByID] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Qscc_GetBlockByTxID] = CHANNELREADERS
 
 	//--------------- CSCC resources -----------
 	//p resources (implemented by the chaincode currently)
-	d.pResourcePolicyMap[resources.CSCC_JoinChain] = ""
-	d.pResourcePolicyMap[resources.CSCC_GetChannels] = ""
+	d.pResourcePolicyMap[resources.Cscc_JoinChain] = ""
+	d.pResourcePolicyMap[resources.Cscc_GetChannels] = ""
 
 	//c resources
-	d.cResourcePolicyMap[resources.CSCC_GetConfigBlock] = CHANNELREADERS
-	d.cResourcePolicyMap[resources.CSCC_GetConfigTree] = CHANNELREADERS
-	d.cResourcePolicyMap[resources.CSCC_SimulateConfigTreeUpdate] = CHANNELWRITERS
+	d.cResourcePolicyMap[resources.Cscc_GetConfigBlock] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Cscc_GetConfigTree] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Cscc_SimulateConfigTreeUpdate] = CHANNELWRITERS
 
 	//---------------- non-scc resources ------------
-	//Propose
-	d.cResourcePolicyMap[resources.PROPOSE] = CHANNELWRITERS
+	//Peer resources
+	d.cResourcePolicyMap[resources.Peer_Propose] = CHANNELWRITERS
+	d.cResourcePolicyMap[resources.Peer_ChaincodeToChaincode] = CHANNELWRITERS
 
-	//Chaincode-to-Chaincode
-	d.cResourcePolicyMap[resources.CC2CC] = CHANNELWRITERS
-
-	//Events (not used currently - for future)
-	d.cResourcePolicyMap[resources.BLOCKEVENT] = CHANNELREADERS
-	d.cResourcePolicyMap[resources.FILTEREDBLOCKEVENT] = CHANNELREADERS
+	//Event resources
+	d.cResourcePolicyMap[resources.Event_Block] = CHANNELREADERS
+	d.cResourcePolicyMap[resources.Event_FilteredBlock] = CHANNELREADERS
 }
 
 //this should cover an exhaustive list of everything called from the peer
diff --git a/core/aclmgmt/resources/resources.go b/core/aclmgmt/resources/resources.go
index 7f734e8..770cea5 100644
--- a/core/aclmgmt/resources/resources.go
+++ b/core/aclmgmt/resources/resources.go
@@ -7,40 +7,39 @@ SPDX-License-Identifier: Apache-2.0
 package resources
 
 //fabric resources used for ACL checks. Note that some of the checks
-//such as LSCC_INSTALL are "peer wide" (current access checks in peer are
+//such as Lscc_INSTALL are "peer wide" (current access checks in peer are
 //based on local MSP). These are not currently covered by resource or default
 //ACLProviders
 const (
-	PROPOSE = "PROPOSE"
-
-	//LSCC resources
-	LSCC_INSTALL                = "LSCC.INSTALL"
-	LSCC_DEPLOY                 = "LSCC.DEPLOY"
-	LSCC_UPGRADE                = "LSCC.UPGRADE"
-	LSCC_GETCCINFO              = "LSCC.GETCCINFO"
-	LSCC_GETDEPSPEC             = "LSCC.GETDEPSPEC"
-	LSCC_GETCCDATA              = "LSCC.GETCCDATA"
-	LSCC_GETCHAINCODES          = "LSCC.GETCHAINCODES"
-	LSCC_GETINSTALLEDCHAINCODES = "LSCC.GETINSTALLEDCHAINCODES"
-
-	//QSCC resources
-	QSCC_GetChainInfo       = "QSCC.GetChainInfo"
-	QSCC_GetBlockByNumber   = "QSCC.GetBlockByNumber"
-	QSCC_GetBlockByHash     = "QSCC.GetBlockByHash"
-	QSCC_GetTransactionByID = "QSCC.GetTransactionByID"
-	QSCC_GetBlockByTxID     = "QSCC.GetBlockByTxID"
-
-	//CSCC resources
-	CSCC_JoinChain                = "CSCC.JoinChain"
-	CSCC_GetConfigBlock           = "CSCC.GetConfigBlock"
-	CSCC_GetChannels              = "CSCC.GetChannels"
-	CSCC_GetConfigTree            = "CSCC.GetConfigTree"
-	CSCC_SimulateConfigTreeUpdate = "CSCC.SimulateConfigTreeUpdate"
-
-	//Chaincode-to-Chaincode call
-	CC2CC = "CC2CC"
+	//Lscc resources
+	Lscc_Install                   = "lscc.Install"
+	Lscc_Deploy                    = "lscc.Deploy"
+	Lscc_Upgrade                   = "lscc.Upgrade"
+	Lscc_ChaincodeExists           = "lscc.ChaincodeExists"
+	Lscc_GetDeploymentSpec         = "lscc.GetDeploymentSpec"
+	Lscc_GetChaincodeData          = "lscc.GetChaincodeData"
+	Lscc_GetInstantiatedChaincodes = "lscc.GetInstantiatedChaincodes"
+	Lscc_GetInstalledChaincodes    = "lscc.GetInstalledChaincodes"
+
+	//Qscc resources
+	Qscc_GetChainInfo       = "qscc.GetChainInfo"
+	Qscc_GetBlockByNumber   = "qscc.GetBlockByNumber"
+	Qscc_GetBlockByHash     = "qscc.GetBlockByHash"
+	Qscc_GetTransactionByID = "qscc.GetTransactionByID"
+	Qscc_GetBlockByTxID     = "qscc.GetBlockByTxID"
+
+	//Cscc resources
+	Cscc_JoinChain                = "cscc.JoinChain"
+	Cscc_GetConfigBlock           = "cscc.GetConfigBlock"
+	Cscc_GetChannels              = "cscc.GetChannels"
+	Cscc_GetConfigTree            = "cscc.GetConfigTree"
+	Cscc_SimulateConfigTreeUpdate = "cscc.SimulateConfigTreeUpdate"
+
+	//Peer resources
+	Peer_Propose              = "peer.Propose"
+	Peer_ChaincodeToChaincode = "peer.ChaincodeToChaincode"
 
 	//Events
-	BLOCKEVENT         = "BLOCKEVENT"
-	FILTEREDBLOCKEVENT = "FILTEREDBLOCKEVENT"
+	Event_Block         = "event.Block"
+	Event_FilteredBlock = "event.FilteredBlock"
 )
diff --git a/core/chaincode/chaincode_support_test.go b/core/chaincode/chaincode_support_test.go
index d0d512e..e702bec 100644
--- a/core/chaincode/chaincode_support_test.go
+++ b/core/chaincode/chaincode_support_test.go
@@ -382,9 +382,9 @@ func initializeCC(t *testing.T, chainID, ccname string, ccSide *mockpeer.MockCCC
 
 	//setup CheckACL calls
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID, sprop).Return(nil)
 
 	//bad txid in response (should be "1"), should fail
 	resp := &mockpeer.MockResponse{&pb.ChaincodeMessage{Type: pb.ChaincodeMessage_TRANSACTION}, &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_COMPLETED, Payload: putils.MarshalOrPanic(&pb.Response{Status: shim.OK, Payload: []byte("init succeeded")}), Txid: "unknowntxid", ChannelId: chainID}}
@@ -443,9 +443,9 @@ func invokeCC(t *testing.T, chainID, ccname string, ccSide *mockpeer.MockCCComm)
 
 	//setup CheckACL calls
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID, sprop).Return(nil)
 
 	respSet := &mockpeer.MockResponseSet{errorFunc, nil, []*mockpeer.MockResponse{
 		{&pb.ChaincodeMessage{Type: pb.ChaincodeMessage_TRANSACTION}, &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_GET_STATE, Payload: putils.MarshalOrPanic(&pb.GetState{Collection: "", Key: "A"}), Txid: txid, ChannelId: chainID}},
@@ -544,9 +544,9 @@ func getQueryStateByRange(t *testing.T, collection, chainID, ccname string, ccSi
 
 	//setup CheckACL calls
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID, sprop).Return(nil)
 
 	//create the response
 	queryStateNextFunc := func(reqMsg *pb.ChaincodeMessage) *pb.ChaincodeMessage {
@@ -611,10 +611,10 @@ func cc2cc(t *testing.T, chainID, chainID2, ccname string, ccSide *mockpeer.Mock
 
 	//setup CheckACL calls
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.CC2CC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_ChaincodeToChaincode, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID, sprop).Return(nil)
 
 	cccid := ccprovider.NewCCContext(chainID, calledCC, "0", txid, false, sprop, prop)
 
@@ -632,13 +632,13 @@ func cc2cc(t *testing.T, chainID, chainID2, ccname string, ccSide *mockpeer.Mock
 
 	//we want hooks for both chaincodes
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.CC2CC, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.CC2CC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_ChaincodeToChaincode, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_ChaincodeToChaincode, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID, sprop).Return(nil)
 
 	sysCCVers := util.GetSysCCVersion()
 	//call a callable system CC, a regular cc, a regular but different cc on a different chain, a regular but same cc on a different chain,  and an uncallable system cc and expect an error inthe last one
@@ -666,13 +666,13 @@ func cc2cc(t *testing.T, chainID, chainID2, ccname string, ccSide *mockpeer.Mock
 	ctxt, txsim, sprop, prop = startTx(t, chainID, cis, txid)
 
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.CC2CC, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.CC2CC, chainID, sprop).Return(errors.New("Bad ACL calling CC"))
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_ChaincodeToChaincode, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_ChaincodeToChaincode, chainID, sprop).Return(errors.New("Bad ACL calling CC"))
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID, sprop).Return(nil)
 	//call regular cc but without ACL on called CC
 	respSet = &mockpeer.MockResponseSet{errorFunc, nil, []*mockpeer.MockResponse{
 		{&pb.ChaincodeMessage{Type: pb.ChaincodeMessage_RESPONSE}, &pb.ChaincodeMessage{Type: pb.ChaincodeMessage_INVOKE_CHAINCODE, Payload: putils.MarshalOrPanic(&pb.ChaincodeSpec{ChaincodeId: &pb.ChaincodeID{Name: "calledCC:0/" + chainID}, Input: &pb.ChaincodeInput{Args: [][]byte{{}}}}), Txid: txid, ChannelId: chainID}}}}
@@ -705,9 +705,9 @@ func getQueryResult(t *testing.T, collection, chainID, ccname string, ccSide *mo
 	ctxt, txsim, sprop, prop := startTx(t, chainID, cis, txid)
 
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID, sprop).Return(nil)
 
 	kvs := make([]*plgr.KV, 1000)
 	for i := 0; i < 1000; i++ {
@@ -773,9 +773,9 @@ func getHistory(t *testing.T, chainID, ccname string, ccSide *mockpeer.MockCCCom
 	ctxt, txsim, sprop, prop := startTx(t, chainID, cis, txid)
 
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID, sprop).Return(nil)
 
 	kvs := make([]*plgr.KV, 1000)
 	for i := 0; i < 1000; i++ {
@@ -1070,10 +1070,10 @@ func cc2SameCC(t *testing.T, chainID, chainID2, ccname string, ccSide *mockpeer.
 
 	//setup CheckACL calls
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.CC2CC, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_ChaincodeToChaincode, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID2, sprop).Return(nil)
 
 	cccid := ccprovider.NewCCContext(chainID2, ccname, "0", txid, false, sprop, prop)
 
@@ -1095,15 +1095,15 @@ func cc2SameCC(t *testing.T, chainID, chainID2, ccname string, ccSide *mockpeer.
 	txid = util.GenerateUUID()
 	ctxt, txsim, sprop, prop = startTx(t, chainID, cis, txid)
 
-	mockAclProvider.On("CheckACL", resources.CC2CC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_ChaincodeToChaincode, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID, sprop).Return(nil)
 
-	mockAclProvider.On("CheckACL", resources.CC2CC, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, chainID2, sprop).Return(nil)
-	mockAclProvider.On("CheckACL", resources.PROPOSE, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_ChaincodeToChaincode, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, chainID2, sprop).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Peer_Propose, chainID2, sprop).Return(nil)
 
 	txid = "cctosamecctx"
 	respSet := &mockpeer.MockResponseSet{errorFunc, nil, []*mockpeer.MockResponse{
diff --git a/core/chaincode/handler.go b/core/chaincode/handler.go
index b96c30d..1b1b652 100644
--- a/core/chaincode/handler.go
+++ b/core/chaincode/handler.go
@@ -259,7 +259,7 @@ func (handler *Handler) checkACL(signedProp *pb.SignedProposal, proposal *pb.Pro
 		return errors.Errorf("signed proposal must not be nil from caller [%s]", ccIns.String())
 	}
 
-	return aclmgmt.GetACLProvider().CheckACL(resources.CC2CC, ccIns.ChainID, signedProp)
+	return aclmgmt.GetACLProvider().CheckACL(resources.Peer_ChaincodeToChaincode, ccIns.ChainID, signedProp)
 }
 
 func (handler *Handler) deregister() error {
diff --git a/core/endorser/support.go b/core/endorser/support.go
index 494c14b..fdef570 100644
--- a/core/endorser/support.go
+++ b/core/endorser/support.go
@@ -108,7 +108,7 @@ func (s *SupportImpl) GetChaincodeDefinition(ctx context.Context, chainID string
 //CheckACL checks the ACL for the resource for the channel using the
 //SignedProposal from which an id can be extracted for testing against a policy
 func (s *SupportImpl) CheckACL(signedProp *pb.SignedProposal, chdr *common.ChannelHeader, shdr *common.SignatureHeader, hdrext *pb.ChaincodeHeaderExtension) error {
-	return aclmgmt.GetACLProvider().CheckACL(resources.PROPOSE, chdr.ChannelId, signedProp)
+	return aclmgmt.GetACLProvider().CheckACL(resources.Peer_Propose, chdr.ChannelId, signedProp)
 }
 
 // IsJavaCC returns true if the CDS package bytes describe a chaincode
diff --git a/core/peer/deliverevents.go b/core/peer/deliverevents.go
index b461190..b7b8b0c 100644
--- a/core/peer/deliverevents.go
+++ b/core/peer/deliverevents.go
@@ -114,7 +114,7 @@ func (s *server) DeliverFiltered(srv peer.Deliver_DeliverFilteredServer) error {
 		Deliver_DeliverFilteredServer: srv,
 	}
 	// getting policy checker based on resources.FILTEREDBLOCKEVENT resource name
-	return s.dh.Handle(deliver.NewDeliverServer(srvSupport, s.policyCheckerProvider(resources.FILTEREDBLOCKEVENT), s.sendProducer(srv)))
+	return s.dh.Handle(deliver.NewDeliverServer(srvSupport, s.policyCheckerProvider(resources.Event_FilteredBlock), s.sendProducer(srv)))
 }
 
 // Deliver sends a stream of blocks to a client after commitment
@@ -125,7 +125,7 @@ func (s *server) Deliver(srv peer.Deliver_DeliverServer) error {
 		Deliver_DeliverServer: srv,
 	}
 	// getting policy checker based on resources.BLOCKEVENT resource name
-	return s.dh.Handle(deliver.NewDeliverServer(srvSupport, s.policyCheckerProvider(resources.BLOCKEVENT), s.sendProducer(srv)))
+	return s.dh.Handle(deliver.NewDeliverServer(srvSupport, s.policyCheckerProvider(resources.Event_Block), s.sendProducer(srv)))
 }
 
 // NewDeliverEventsServer creates a peer.Deliver server to deliver block and
diff --git a/core/scc/cscc/configure.go b/core/scc/cscc/configure.go
index 99df52a..d846c25 100644
--- a/core/scc/cscc/configure.go
+++ b/core/scc/cscc/configure.go
@@ -140,21 +140,21 @@ func (e *PeerConfiger) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
 		return joinChain(cid, block)
 	case GetConfigBlock:
 		// 2. check policy
-		if err = aclmgmt.GetACLProvider().CheckACL(resources.CSCC_GetConfigBlock, string(args[1]), sp); err != nil {
+		if err = aclmgmt.GetACLProvider().CheckACL(resources.Cscc_GetConfigBlock, string(args[1]), sp); err != nil {
 			return shim.Error(fmt.Sprintf("\"GetConfigBlock\" request failed authorization check for channel [%s]: [%s]", args[1], err))
 		}
 
 		return getConfigBlock(args[1])
 	case GetConfigTree:
 		// 2. check policy
-		if err = aclmgmt.GetACLProvider().CheckACL(resources.CSCC_GetConfigTree, string(args[1]), sp); err != nil {
+		if err = aclmgmt.GetACLProvider().CheckACL(resources.Cscc_GetConfigTree, string(args[1]), sp); err != nil {
 			return shim.Error(fmt.Sprintf("\"GetConfigTree\" request failed authorization check for channel [%s]: [%s]", args[1], err))
 		}
 
 		return e.getConfigTree(args[1])
 	case SimulateConfigTreeUpdate:
 		// Check policy
-		if err = aclmgmt.GetACLProvider().CheckACL(resources.CSCC_SimulateConfigTreeUpdate, string(args[1]), sp); err != nil {
+		if err = aclmgmt.GetACLProvider().CheckACL(resources.Cscc_SimulateConfigTreeUpdate, string(args[1]), sp); err != nil {
 			return shim.Error(fmt.Sprintf("\"SimulateConfigTreeUpdate\" request failed authorization check for channel [%s]: [%s]", args[1], err))
 		}
 		return e.simulateConfigTreeUpdate(args[1], args[2])
diff --git a/core/scc/cscc/configure_test.go b/core/scc/cscc/configure_test.go
index 121c947..082c6bb 100644
--- a/core/scc/cscc/configure_test.go
+++ b/core/scc/cscc/configure_test.go
@@ -133,7 +133,7 @@ func TestConfigerInvokeInvalidParameters(t *testing.T) {
 	assert.Equal(t, res.Message, "Requested function fooFunction not found.")
 
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.CSCC_GetConfigBlock, "testChainID", (*pb.SignedProposal)(nil)).Return(errors.New("Nil SignedProposal"))
+	mockAclProvider.On("CheckACL", resources.Cscc_GetConfigBlock, "testChainID", (*pb.SignedProposal)(nil)).Return(errors.New("Nil SignedProposal"))
 	args = [][]byte{[]byte("GetConfigBlock"), []byte("testChainID")}
 	res = stub.MockInvokeWithSignedProposal("4", args, nil)
 	assert.Equal(t, res.Status, int32(shim.ERROR), "CSCC invoke expected to fail no signed proposal provided")
@@ -275,7 +275,7 @@ func TestConfigerInvokeJoinChainCorrectParams(t *testing.T) {
 
 	// Test an ACL failure on GetConfigBlock
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.CSCC_GetConfigBlock, "mytestchainid", sProp).Return(errors.New("Failed authorization"))
+	mockAclProvider.On("CheckACL", resources.Cscc_GetConfigBlock, "mytestchainid", sProp).Return(errors.New("Failed authorization"))
 	args = [][]byte{[]byte("GetConfigBlock"), []byte(chainID)}
 	res = stub.MockInvokeWithSignedProposal("2", args, sProp)
 	if res.Status == shim.OK {
@@ -286,7 +286,7 @@ func TestConfigerInvokeJoinChainCorrectParams(t *testing.T) {
 
 	// Test with ACL okay
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.CSCC_GetConfigBlock, "mytestchainid", sProp).Return(nil)
+	mockAclProvider.On("CheckACL", resources.Cscc_GetConfigBlock, "mytestchainid", sProp).Return(nil)
 	if res := stub.MockInvokeWithSignedProposal("2", args, sProp); res.Status != shim.OK {
 		t.Fatalf("cscc invoke GetConfigBlock failed with: %v", res.Message)
 	}
diff --git a/core/scc/lscc/lscc.go b/core/scc/lscc/lscc.go
index 3b61f2c..8b4c55c 100644
--- a/core/scc/lscc/lscc.go
+++ b/core/scc/lscc/lscc.go
@@ -63,8 +63,8 @@ const (
 	//UPGRADE upgrade chaincode
 	UPGRADE = "upgrade"
 
-	//GETCCINFO get chaincode
-	GETCCINFO = "getid"
+	//CCEXISTS get chaincode
+	CCEXISTS = "getid"
 
 	//GETDEPSPEC get ChaincodeDeploymentSpec
 	GETDEPSPEC = "getdepspec"
@@ -721,7 +721,7 @@ func (lscc *lifeCycleSysCC) Invoke(stub shim.ChaincodeStubInterface) pb.Response
 			return shim.Error(err.Error())
 		}
 		return shim.Success(cdbytes)
-	case GETCCINFO, GETDEPSPEC, GETCCDATA:
+	case CCEXISTS, GETDEPSPEC, GETCCDATA:
 		if len(args) != 3 {
 			return shim.Error(InvalidArgsLenErr(len(args)).Error())
 		}
@@ -732,12 +732,12 @@ func (lscc *lifeCycleSysCC) Invoke(stub shim.ChaincodeStubInterface) pb.Response
 		// 2. check local Channel Readers policy
 		var resource string
 		switch function {
-		case GETCCINFO:
-			resource = resources.LSCC_GETCCINFO
+		case CCEXISTS:
+			resource = resources.Lscc_ChaincodeExists
 		case GETDEPSPEC:
-			resource = resources.LSCC_GETDEPSPEC
+			resource = resources.Lscc_GetDeploymentSpec
 		case GETCCDATA:
-			resource = resources.LSCC_GETCCDATA
+			resource = resources.Lscc_GetChaincodeData
 		}
 		if err = aclmgmt.GetACLProvider().CheckACL(resource, chain, sp); err != nil {
 			return shim.Error(fmt.Sprintf("Authorization request failed %s: %s", chain, err))
@@ -750,7 +750,7 @@ func (lscc *lifeCycleSysCC) Invoke(stub shim.ChaincodeStubInterface) pb.Response
 		}
 
 		switch function {
-		case GETCCINFO:
+		case CCEXISTS:
 			cd, err := lscc.getChaincodeData(ccname, cdbytes)
 			if err != nil {
 				return shim.Error(err.Error())
diff --git a/core/scc/lscc/lscc_test.go b/core/scc/lscc/lscc_test.go
index a6f2815..132efd0 100644
--- a/core/scc/lscc/lscc_test.go
+++ b/core/scc/lscc/lscc_test.go
@@ -270,13 +270,13 @@ func testDeploy(t *testing.T, ccname string, version string, path string, forceB
 		assert.Equal(t, res.Status, int32(shim.OK), res.Message)
 
 		mockAclProvider.Reset()
-		mockAclProvider.On("CheckACL", resources.LSCC_GETCCINFO, "test", sProp).Return(nil)
-		args = [][]byte{[]byte(GETCCINFO), []byte("test"), []byte(cds.ChaincodeSpec.ChaincodeId.Name)}
+		mockAclProvider.On("CheckACL", resources.Lscc_ChaincodeExists, "test", sProp).Return(nil)
+		args = [][]byte{[]byte(CCEXISTS), []byte("test"), []byte(cds.ChaincodeSpec.ChaincodeId.Name)}
 		res = stub.MockInvokeWithSignedProposal("1", args, sProp)
 		assert.Equal(t, res.Status, int32(shim.OK), res.Message)
 
 		mockAclProvider.Reset()
-		mockAclProvider.On("CheckACL", resources.LSCC_GETDEPSPEC, "test", sProp).Return(nil)
+		mockAclProvider.On("CheckACL", resources.Lscc_GetDeploymentSpec, "test", sProp).Return(nil)
 		args = [][]byte{[]byte(GETDEPSPEC), []byte("test"), []byte(cds.ChaincodeSpec.ChaincodeId.Name)}
 		res = stub.MockInvokeWithSignedProposal("1", args, sProp)
 		assert.Equal(t, res.Status, int32(shim.OK), res.Message)
@@ -290,7 +290,7 @@ func testDeploy(t *testing.T, ccname string, version string, path string, forceB
 
 		scc.support.(*lscc.MockSupport).GetChaincodeFromLocalStorageRv = nil
 		mockAclProvider.Reset()
-		mockAclProvider.On("CheckACL", resources.LSCC_GETCCDATA, "test", sProp).Return(nil)
+		mockAclProvider.On("CheckACL", resources.Lscc_GetChaincodeData, "test", sProp).Return(nil)
 		args = [][]byte{[]byte(GETCCDATA), []byte("test"), []byte(cds.ChaincodeSpec.ChaincodeId.Name)}
 		res = stub.MockInvokeWithSignedProposal("1", args, sProp)
 		assert.Equal(t, res.Status, int32(shim.OK), res.Message)
@@ -298,7 +298,7 @@ func testDeploy(t *testing.T, ccname string, version string, path string, forceB
 		assert.Equal(t, expectedErrorMsg, string(res.Message))
 	}
 
-	res = stub.MockInvokeWithSignedProposal("1", [][]byte{[]byte(GETCCINFO)}, nil)
+	res = stub.MockInvokeWithSignedProposal("1", [][]byte{[]byte(CCEXISTS)}, nil)
 }
 
 // TestUpgrade tests the upgrade function with various inputs for basic use cases
@@ -402,7 +402,7 @@ func TestGETCCINFO(t *testing.T) {
 	res := stub.MockInit("1", nil)
 	assert.Equal(t, res.Status, int32(shim.OK), res.Message)
 
-	res = stub.MockInvokeWithSignedProposal("1", [][]byte{[]byte(GETCCINFO), []byte("chain")}, nil)
+	res = stub.MockInvokeWithSignedProposal("1", [][]byte{[]byte(CCEXISTS), []byte("chain")}, nil)
 	assert.NotEqual(t, res.Status, int32(shim.OK), res.Message)
 
 	identityDeserializer := &policymocks.MockIdentityDeserializer{[]byte("Alice"), []byte("msg1")}
@@ -421,13 +421,13 @@ func TestGETCCINFO(t *testing.T) {
 	sProp.Signature = sProp.ProposalBytes
 
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCINFO, "chain", sProp).Return(errors.New("Failed access control"))
-	res = stub.MockInvokeWithSignedProposal("1", [][]byte{[]byte(GETCCINFO), []byte("chain"), []byte("chaincode")}, sProp)
+	mockAclProvider.On("CheckACL", resources.Lscc_ChaincodeExists, "chain", sProp).Return(errors.New("Failed access control"))
+	res = stub.MockInvokeWithSignedProposal("1", [][]byte{[]byte(CCEXISTS), []byte("chain"), []byte("chaincode")}, sProp)
 	assert.NotEqual(t, res.Status, int32(shim.OK), res.Message)
 
 	mockAclProvider.Reset()
-	mockAclProvider.On("CheckACL", resources.LSCC_GETCCINFO, "chain", sProp).Return(nil)
-	res = stub.MockInvokeWithSignedProposal("1", [][]byte{[]byte(GETCCINFO), []byte("chain"), []byte("nonexistentchaincode")}, sProp)
+	mockAclProvider.On("CheckACL", resources.Lscc_ChaincodeExists, "chain", sProp).Return(nil)
+	res = stub.MockInvokeWithSignedProposal("1", [][]byte{[]byte(CCEXISTS), []byte("chain"), []byte("nonexistentchaincode")}, sProp)
 	assert.NotEqual(t, res.Status, int32(shim.OK), res.Message)
 }
 
diff --git a/core/scc/qscc/query.go b/core/scc/qscc/query.go
index 20c59a1..69699ee 100644
--- a/core/scc/qscc/query.go
+++ b/core/scc/qscc/query.go
@@ -209,5 +209,5 @@ func getBlockByTxID(vledger ledger.PeerLedger, rawTxID []byte) pb.Response {
 }
 
 func getACLResource(fname string) string {
-	return "QSCC." + fname
+	return "qscc." + fname
 }
diff --git a/core/scc/qscc/query_test.go b/core/scc/qscc/query_test.go
index e202b85..615a0a6 100644
--- a/core/scc/qscc/query_test.go
+++ b/core/scc/qscc/query_test.go
@@ -68,7 +68,7 @@ func TestQueryGetChainInfo(t *testing.T) {
 	}
 
 	args := [][]byte{[]byte(GetChainInfo), []byte(chainid)}
-	prop := resetProvider(resources.QSCC_GetChainInfo, chainid, &peer2.SignedProposal{}, nil)
+	prop := resetProvider(resources.Qscc_GetChainInfo, chainid, &peer2.SignedProposal{}, nil)
 	res := stub.MockInvokeWithSignedProposal("1", args, prop)
 	assert.Equal(t, int32(shim.OK), res.Status, "GetChainInfo failed with err: %s", res.Message)
 
@@ -91,7 +91,7 @@ func TestQueryGetTransactionByID(t *testing.T) {
 	}
 
 	args := [][]byte{[]byte(GetTransactionByID), []byte(chainid), []byte("1")}
-	prop := resetProvider(resources.QSCC_GetTransactionByID, chainid, &peer2.SignedProposal{}, nil)
+	prop := resetProvider(resources.Qscc_GetTransactionByID, chainid, &peer2.SignedProposal{}, nil)
 	res := stub.MockInvokeWithSignedProposal("1", args, prop)
 	assert.Equal(t, int32(shim.ERROR), res.Status, "GetTransactionByID should have failed with invalid txid: 1")
 
@@ -116,7 +116,7 @@ func TestQueryGetBlockByNumber(t *testing.T) {
 
 	// block number 0 (genesis block) would already be present in the ledger
 	args := [][]byte{[]byte(GetBlockByNumber), []byte(chainid), []byte("0")}
-	prop := resetProvider(resources.QSCC_GetBlockByNumber, chainid, &peer2.SignedProposal{}, nil)
+	prop := resetProvider(resources.Qscc_GetBlockByNumber, chainid, &peer2.SignedProposal{}, nil)
 	res := stub.MockInvokeWithSignedProposal("1", args, prop)
 	assert.Equal(t, int32(shim.OK), res.Status, "GetBlockByNumber should have succeeded for block number: 0")
 
@@ -141,7 +141,7 @@ func TestQueryGetBlockByHash(t *testing.T) {
 	}
 
 	args := [][]byte{[]byte(GetBlockByHash), []byte(chainid), []byte("0")}
-	prop := resetProvider(resources.QSCC_GetBlockByHash, chainid, &peer2.SignedProposal{}, nil)
+	prop := resetProvider(resources.Qscc_GetBlockByHash, chainid, &peer2.SignedProposal{}, nil)
 	res := stub.MockInvokeWithSignedProposal("1", args, prop)
 	assert.Equal(t, int32(shim.ERROR), res.Status, "GetBlockByHash should have failed with invalid hash: 0")
 
@@ -160,7 +160,7 @@ func TestQueryGetBlockByTxID(t *testing.T) {
 	}
 
 	args := [][]byte{[]byte(GetBlockByTxID), []byte(chainid), []byte("")}
-	prop := resetProvider(resources.QSCC_GetBlockByTxID, chainid, &peer2.SignedProposal{}, nil)
+	prop := resetProvider(resources.Qscc_GetBlockByTxID, chainid, &peer2.SignedProposal{}, nil)
 	res := stub.MockInvokeWithSignedProposal("1", args, prop)
 	assert.Equal(t, int32(shim.ERROR), res.Status, "GetBlockByTxID should have failed with blank txId.")
 }
@@ -181,7 +181,7 @@ func TestFailingAccessControl(t *testing.T) {
 	sProp, _ := utils.MockSignedEndorserProposalOrPanic(chainid, &peer2.ChaincodeSpec{}, []byte("Alice"), []byte("msg1"))
 	sProp.Signature = sProp.ProposalBytes
 	// Set the ACLProvider to have a failure
-	resetProvider(resources.QSCC_GetChainInfo, chainid, sProp, errors.New("Failed access control"))
+	resetProvider(resources.Qscc_GetChainInfo, chainid, sProp, errors.New("Failed access control"))
 	res := stub.MockInvokeWithSignedProposal("2", args, sProp)
 	assert.Equal(t, int32(shim.ERROR), res.Status, "GetChainInfo must fail: %s", res.Message)
 	assert.Contains(t, res.Message, "Failed access control")
@@ -193,7 +193,7 @@ func TestFailingAccessControl(t *testing.T) {
 	sProp, _ = utils.MockSignedEndorserProposalOrPanic(chainid, &peer2.ChaincodeSpec{}, []byte("Alice"), []byte("msg1"))
 	sProp.Signature = sProp.ProposalBytes
 	// Set the ACLProvider to have a failure
-	resetProvider(resources.QSCC_GetBlockByNumber, chainid, sProp, errors.New("Failed access control"))
+	resetProvider(resources.Qscc_GetBlockByNumber, chainid, sProp, errors.New("Failed access control"))
 	res = stub.MockInvokeWithSignedProposal("2", args, sProp)
 	assert.Equal(t, int32(shim.ERROR), res.Status, "GetBlockByNumber must fail: %s", res.Message)
 	assert.Contains(t, res.Message, "Failed access control")
@@ -205,7 +205,7 @@ func TestFailingAccessControl(t *testing.T) {
 	sProp, _ = utils.MockSignedEndorserProposalOrPanic(chainid, &peer2.ChaincodeSpec{}, []byte("Alice"), []byte("msg1"))
 	sProp.Signature = sProp.ProposalBytes
 	// Set the ACLProvider to have a failure
-	resetProvider(resources.QSCC_GetBlockByHash, chainid, sProp, errors.New("Failed access control"))
+	resetProvider(resources.Qscc_GetBlockByHash, chainid, sProp, errors.New("Failed access control"))
 	res = stub.MockInvokeWithSignedProposal("2", args, sProp)
 	assert.Equal(t, int32(shim.ERROR), res.Status, "GetBlockByHash must fail: %s", res.Message)
 	assert.Contains(t, res.Message, "Failed access control")
@@ -217,7 +217,7 @@ func TestFailingAccessControl(t *testing.T) {
 	sProp, _ = utils.MockSignedEndorserProposalOrPanic(chainid, &peer2.ChaincodeSpec{}, []byte("Alice"), []byte("msg1"))
 	sProp.Signature = sProp.ProposalBytes
 	// Set the ACLProvider to have a failure
-	resetProvider(resources.QSCC_GetBlockByTxID, chainid, sProp, errors.New("Failed access control"))
+	resetProvider(resources.Qscc_GetBlockByTxID, chainid, sProp, errors.New("Failed access control"))
 	res = stub.MockInvokeWithSignedProposal("2", args, sProp)
 	assert.Equal(t, int32(shim.ERROR), res.Status, "GetBlockByTxID must fail: %s", res.Message)
 	assert.Contains(t, res.Message, "Failed access control")
@@ -229,9 +229,9 @@ func TestFailingAccessControl(t *testing.T) {
 	sProp, _ = utils.MockSignedEndorserProposalOrPanic(chainid, &peer2.ChaincodeSpec{}, []byte("Alice"), []byte("msg1"))
 	sProp.Signature = sProp.ProposalBytes
 	// Set the ACLProvider to have a failure
-	resetProvider(resources.QSCC_GetTransactionByID, chainid, sProp, errors.New("Failed access control"))
+	resetProvider(resources.Qscc_GetTransactionByID, chainid, sProp, errors.New("Failed access control"))
 	res = stub.MockInvokeWithSignedProposal("2", args, sProp)
-	assert.Equal(t, int32(shim.ERROR), res.Status, "QSCC_GetTransactionByID must fail: %s", res.Message)
+	assert.Equal(t, int32(shim.ERROR), res.Status, "Qscc_GetTransactionByID must fail: %s", res.Message)
 	assert.Contains(t, res.Message, "Failed access control")
 	// assert that the expectations were met
 	mockAclProvider.AssertExpectations(t)
@@ -247,7 +247,7 @@ func TestQueryNonexistentFunction(t *testing.T) {
 	}
 
 	args := [][]byte{[]byte("GetBlocks"), []byte(chainid), []byte("arg1")}
-	prop := resetProvider("QSCC.GetBlocks", chainid, &peer2.SignedProposal{}, nil)
+	prop := resetProvider("qscc.GetBlocks", chainid, &peer2.SignedProposal{}, nil)
 	res := stub.MockInvokeWithSignedProposal("1", args, prop)
 	assert.Equal(t, int32(shim.ERROR), res.Status, "GetBlocks should have failed because the function does not exist")
 }
@@ -267,13 +267,13 @@ func TestQueryGeneratedBlock(t *testing.T) {
 
 	// block number 1 should now exist
 	args := [][]byte{[]byte(GetBlockByNumber), []byte(chainid), []byte("1")}
-	prop := resetProvider(resources.QSCC_GetBlockByNumber, chainid, &peer2.SignedProposal{}, nil)
+	prop := resetProvider(resources.Qscc_GetBlockByNumber, chainid, &peer2.SignedProposal{}, nil)
 	res := stub.MockInvokeWithSignedProposal("1", args, prop)
 	assert.Equal(t, int32(shim.OK), res.Status, "GetBlockByNumber should have succeeded for block number 1")
 
 	// block number 1
 	args = [][]byte{[]byte(GetBlockByHash), []byte(chainid), []byte(block1.Header.Hash())}
-	prop = resetProvider(resources.QSCC_GetBlockByHash, chainid, &peer2.SignedProposal{}, nil)
+	prop = resetProvider(resources.Qscc_GetBlockByHash, chainid, &peer2.SignedProposal{}, nil)
 	res = stub.MockInvokeWithSignedProposal("2", args, prop)
 	assert.Equal(t, int32(shim.OK), res.Status, "GetBlockByHash should have succeeded for block 1 hash")
 
@@ -295,12 +295,12 @@ func TestQueryGeneratedBlock(t *testing.T) {
 				if common.HeaderType(chdr.Type) == common.HeaderType_ENDORSER_TRANSACTION {
 					args = [][]byte{[]byte(GetBlockByTxID), []byte(chainid), []byte(chdr.TxId)}
 					mockAclProvider.Reset()
-					prop = resetProvider(resources.QSCC_GetBlockByTxID, chainid, &peer2.SignedProposal{}, nil)
+					prop = resetProvider(resources.Qscc_GetBlockByTxID, chainid, &peer2.SignedProposal{}, nil)
 					res = stub.MockInvokeWithSignedProposal("3", args, prop)
 					assert.Equal(t, int32(shim.OK), res.Status, "GetBlockByTxId should have succeeded for txid: %s", chdr.TxId)
 
 					args = [][]byte{[]byte(GetTransactionByID), []byte(chainid), []byte(chdr.TxId)}
-					prop = resetProvider(resources.QSCC_GetTransactionByID, chainid, &peer2.SignedProposal{}, nil)
+					prop = resetProvider(resources.Qscc_GetTransactionByID, chainid, &peer2.SignedProposal{}, nil)
 					res = stub.MockInvokeWithSignedProposal("4", args, prop)
 					assert.Equal(t, int32(shim.OK), res.Status, "GetTransactionById should have succeeded for txid: %s", chdr.TxId)
 				}
diff --git a/sampleconfig/configtx.yaml b/sampleconfig/configtx.yaml
index bd3e985..a2bf095 100644
--- a/sampleconfig/configtx.yaml
+++ b/sampleconfig/configtx.yaml
@@ -371,34 +371,70 @@ Orderer: &OrdererDefaults
 #
 ################################################################################
 Application: &ApplicationDefaults
-    ACLs:
-        ### TODO --- each of these mappings need to be documented
-        #Lifecycle System Chaincode resource to policy mapping for access control
-        LSCC.GETCCINFO: /Channel/Application/Readers
-        LSCC.GETDEPSPEC: /Channel/Application/Readers
-        LSCC.GETCCDATA: /Channel/Application/Readers
-
-        #Query System Chaincode resource to policy mapping for access control
-        QSCC.GetChainInfo: /Channel/Application/Readers
-        QSCC.GetBlockByNumber: /Channel/Application/Readers
-        QSCC.GetBlockByHash: /Channel/Application/Readers
-        QSCC.GetTransactionByID: /Channel/Application/Readers
-        QSCC.GetBlockByTxID: /Channel/Application/Readers
-
-        #Configuration System Chaincode resource to policy mapping for access control
-        CSCC.GetConfigBlock: /Channel/Application/Readers
-        CSCC.GetConfigTree: /Channel/Application/Readers
-        CSCC.SimulateConfigTreeUpdate: /Channel/Application/Writers
-
-        #Proposal resource to policy mapping default for access control
-        PROPOSAL: /Channel/Application/Writers
-
-        #Chaincode-to-Chaincode invocation resource to policy mapping for access control
-        CC2CC: /Channel/Application/Readers
-
-        #Events resource to policy mapping for access control
-        BLOCKEVENT: /Channel/Application/Readers
-        FILTEREDBLOCKEVENT: /Channel/Application/Readers
+    ACLs: &ACLsDefault
+        #This section provides defaults for policies for various resources
+        #in the system. These "resources" could be functions on system chaincodes
+        #(e.g., "GetBlockByNumber" on the "qscc" system chaincode) or other resources
+        #(e.g.,who can receive Block events). This section does NOT specify the resource's
+        #definition or API, but just the ACL policy for it.
+        #
+        #User's can override these defaults with their own policy mapping by defining the
+        #mapping under ACLs in their channel definition
+
+        #---Lifecycle System Chaincode (lscc) function to policy mapping for access control---#
+
+        #ACL policy for lscc's "getid" function
+        lscc.ChaincodeExists: /Channel/Application/Readers
+
+        #ACL policy for lscc's "getdepspec" function
+        lscc.GetDeploymentSpec: /Channel/Application/Readers
+
+        #ACL policy for lscc's "getccdata" function
+        lscc.GetChaincodeData: /Channel/Application/Readers
+
+        #---Query System Chaincode (qscc) function to policy mapping for access control---#
+
+        #ACL policy for qscc's "GetChainInfo" function
+        qscc.GetChainInfo: /Channel/Application/Readers
+
+        #ACL policy for qscc's "GetBlockByNumber" function
+        qscc.GetBlockByNumber: /Channel/Application/Readers
+
+        #ACL policy for qscc's  "GetBlockByHash" function
+        qscc.GetBlockByHash: /Channel/Application/Readers
+
+        #ACL policy for qscc's "GetTransactionByID" function
+        qscc.GetTransactionByID: /Channel/Application/Readers
+
+        #ACL policy for qscc's "GetBlockByTxID" function
+        qscc.GetBlockByTxID: /Channel/Application/Readers
+
+        #---Configuration System Chaincode (cscc) function to policy mapping for access control---#
+
+        #ACL policy for cscc's "GetConfigBlock" function
+        cscc.GetConfigBlock: /Channel/Application/Readers
+
+        #ACL policy for cscc's "GetConfigTree" function
+        cscc.GetConfigTree: /Channel/Application/Readers
+
+        #ACL policy for cscc's "SimulateConfigTreeUpdate" function
+        cscc.SimulateConfigTreeUpdate: /Channel/Application/Writers
+
+        #---Miscellanesous peer function to policy mapping for access control---#
+
+        #ACL policy for invoking chaincodes on peer
+        peer.Proposal: /Channel/Application/Writers
+
+        #ACL policy for chaincode to chaincode invocation
+        peer.ChaincodeToChaincode: /Channel/Application/Readers
+
+        #---Events resource to policy mapping for access control###---#
+
+        #ACL policy for sending block events
+        event.Block: /Channel/Application/Readers
+
+        #ACL policy for sending filtered block events
+        event.FilteredBlock: /Channel/Application/Readers
 
     # Organizations lists the orgs participating on the application side of the
     # network.
-- 
2.7.4

